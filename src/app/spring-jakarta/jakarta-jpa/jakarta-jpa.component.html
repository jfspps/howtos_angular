<h5>The Java Persistence API (JPA)</h5>

<p>
    The JPA allows Java objects to be mapped to a persistent database. The framework which implements and handles the mapping is referred to as object-relation mapping, or ORM. The ORM handles different database queries, accommodates legacy code and can help perform transactions regardless of where the data is persisted (saved). The default actions can be overridden when required.
</p>

<p>
    The JPA is an interface which is implemented by a number of frameworks or <b>providers</b> or JPA runtime. The default Java EE implementation is <a href="https://www.eclipse.org/eclipselink/" target="_blank">EclipseLink</a> though there are others in use in the enterprise environment including <a href="https://hibernate.org/" target="_blank">Hibernate</a> and <a href="https://spring.io/projects/spring-data-jpa" target="_blank">Spring Data JPA</a>.
</p>

<h5>Setting up the tables and entities</h5>

<p>
    The fundamental (atomic) unit of a JPA component is a POJO, with its class annotated with the @Entity. The @Id annotation is then applied to a field, of type Long, to ensure that each instance is unique with a unique Id.
</p>

<p>
    To this point, the minimum needed to declare a JPA component is done. The name of the table is, without further intervention, the same as the class name. To use a different name, use the @Table(name = "SomeTableName") annotation. So far, the class would look like the following.
</p>

<pre>
    <code [highlight]="jpaTable" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Changing the table name enables POJOs to be stored according to different database requirements. Super classes can form the foundation of JPA entities which have similar fields. This can be implemented by defining an abstract class, itself implementing Serializable.
</p>

<pre>
    <code [highlight]="jpaSuperClass" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The abstract class can then be extended, using the same fields already listed, as follows.
</p>

<pre>
    <code [highlight]="jpaChildClass" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    To override fields in the child class, annotate the child class with @AttributeOverride.
</p>

<pre>
    <code [highlight]="jpaChildClassOverride" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Fields are mapped directly to columns with a column name that is similar to the field name (depends on the JPA implementation), and are by default known as basic fields (types). The optional annotation @Basic of a field, which follows this mapping approach, emphasises this in the code. The actual type stored in the JPA table depends on the implementation. For example, Java Strings are quite often mapped as VARCHAR types.
</p>

<p>
    To customise the JPA column mapping, use the @Column(name = "jpaColumnName") annotation for the desired field. There are other options available, including "length", "nullable" and "unique".
</p>

<p>
    To exclude the mapping of super class or child class field, use the @Transient annotation. In other words, the Java POJO will have a field that is never stored or known when consulting the JPA table. This might be useful if the POJO stores metadata that is not relevant to the database. Otherwise, without the @Transient annotation the field will automatically be mapped as a basic type.
</p>

<h5>Access types</h5>

<p>
    As stated, the JPA implementation is also known as the provider. Access types describe the method which the provider follows to map data to/from the database/Java object. Regarding the Java object, the data can be retrieved or set directly via the fields or though its class' getter and setters.
</p>

<p>
    Take the case when a provider extracts field values from the POJO's fields directly and stores them in the database. This direct mechanism is referred to as "Field Access" and is the default mechanism for all fields of a class, where at least one field not method (normally the @Id annotated field) is given a valid JPA annotation. More fundamentally, the runtime will use 'reflection' to access the field "income" above directly. It will not make use of any getter.
</p>

<p>
    In general, all fields of a class which are then assumed to follow field access are field access types and should be either private or protected. Furthermore, classes which extend said class are also assumed to follow field access. Only the JPA provider will have access to the fields.
</p>

<p>
    "Property Access" is a mechanism where the provider uses getters and setters to access fields' values. The getters and setters must be public. To signal property access of the Id, for example, simply move the @Id annotation from its field to the getter.
</p>

<pre>
    <code [highlight]="jpaPropertyAccess" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Generally, field access tends to be easier to read and is applied more often than property access. It is also possible to follow a "Mixed Access" method which is essentially a mixture of Field and Property access types. This can be achieved by a combination of the @Access and @Transient annotations. This approach is quite rare and not described here.
</p>

<h5>Mapping types and Fetching</h5>

<p>
    Java String types are mapped to the database as VARCHAR (in fact, all mapping types are provider dependent so this discussion attempts to be somewhat generic). Other Java primitive types, wrapper types, enums and Serializable objects can also be mapped to the JPA.
</p>

<p>
    Enum types are normally assigned ordinal values, according to the order they are listed in the class.
</p>

<pre>
    <code [highlight]="jpaEnums" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The ordinals are, by default, stored to the database as integers. This is fine as long as the enumerated list never changes. If however the order changes or an enum is added/removed, then any database stored values will be mis-assigned. To overcome this, the enum can be mapped as a string (a VARCHAR) and use the literal of the enum instead of its ordinal value. In the enum field, use the @Enumerated(EnumType.STRING). Storing as a string tends to be the preferred method.
</p>

<pre>
    <code [highlight]="jpaEnumsFields" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Large entities of variable length (arrays, lists etc.) are represented as CLOBs and BLOBs, that is, character large objects and binary large objects. A primitive array of Java char would be handled by a CLOB whereas a primitive array of Java byte would be handled by a BLOB. The annotation @Lob signals to the JPA provider to handle the Java array or list with large format file routines, optimised for the specific purpose.
</p>

<p>
    When dealing with large files, it is more optimal to retrieve data only when needed, typically through a getter. When an object (a database row) is retrieved from the database, all fields by default (where fields are "eagerly" fetched) are extracted and assigned to the properties of the object. To prevent the JPA provider from retrieving certain fields when a Java object is built with database fields, apply the @Basic(fetch = FetchType.LAZY) annotation to the fields that must be excluded. Only when the object getter (if the field is private) is called does the annotated field get extracted from the database and are said to be "lazily" fetched.
</p>

<p>
    JPA 2.2 introduced support for Java 8's java.time package. The JPA provider will normally use the corresponding Date type in the database. No special annotations are required. Prior version of the JPA required the use of specific annotations to get things going.
</p>

<p>
    Inner classes or classes which are embedded into others (through composition) in Java usually have no purpose other than to serve the Java class they are embedded in. Instances of the outer class typically have fields which are the same type as the inner (embedded) class. To store the inner class, annotate the class to be embedded with @Embeddable and then annotate the field of the class which is embedded with @Embedded. This causes the JPA to save the embedded (inner) class with its own columns, into the 'main class'.
</p>

<pre>
    <code [highlight]="jpaEmbedded" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<h5>Primary keys</h5>

<p>
    Primary keys can take the form of different Java types, not only (wrapped) Long types. Generally, the floating point types like double and Double are not recommended given the representation is not uniformly defined across systems. 
</p>

<p>
    Primary keys generation types vary. The annotation @GeneratedValue(strategy = GenerationType.AUTO) assigns responsibility of primary key generation to the JPA provider and is fine for development. For deployment, this is not recommended since more control is generally expected. The primary key is only set once the transaction (for example, an insertion) has been completed.
</p>

<p>
    The annotation @GeneratedValue(strategy = GenerationType.IDENTITY) directs supporting providers to generate unique primary keys in a primary key column. Not all implementations support a dedicated primary key column.
</p>

<p>
    Some database implementation enable (indeed, expect) custom sequences of integers to be constructed, using the SEQUENCE command. In these cases, the database does not have an automatic schema generator (requires administration). By default, a primary key is constructed as unit integers, that is, the next key is one integer greater than the previous. The SEQUENCE command can be used to define a different sequence. The application of the custom sequence can be directed using the annotations @SequenceGenerator in combination with @GeneratedValue.
</p>

<pre>
    <code [highlight]="jpaCustomSequence" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    A more flexible primary key generator is the Table Generator and tends to be used during deployment. This generates a separate table in the database which specifically acts as a mapper between the Java object and its persistent entity on the database. 
</p>

<pre>
    <code [highlight]="jpaTableGenerator" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Going through each part (above), the name of the table is "pkTable". The primary key column for <i>pkTable</i> is "generatedIDsPKs". The second column in <i>pkTable</i> labelled "latestPK" contains a record of the last primary key that was set. This last column informs the JPA provider what the next key should be, normally one unit integer higher. It examines the value in this column and then proceeds to assign the next entity primary key based on teh value in "latestPK".
</p>

<h5>Relational mapping with JPA</h5>

<p>
    Relationships between two entities can either be unidirectional or bidirectional (explain in more detail shortly). An address related to a employee is normally unidirectional since it makes more sense for the employee to know its address but it does not make sense for an address to know its employee.
</p>

<p>
    The <i>cardinality</i> refers to the number entities at the end of each relationship. From a department's viewpoint, the department will have many employees, and be one-to-many. From the employees viewpoint it would be many-to-one. The cardinality is one for the department and many for the employees, as such.
</p>

<p>
    The <i>ordinality</i> (or "optionality") refers to a boolean which denotes whether or not a entity must be defined when persisting data. Other authors refer to ordinality as the minimum number of entities that must exist in a given relationship. In order for employees to be saved to the database, a department must exist. However, in order for a department to be saved, having employees is not a requirement. From a global viewpoint, the ordinality (in the department-employee relationship) is said to be "0" or false for employee and "1+" or true for the department.
</p>

<h5>Single-valued associations</h5>

<p>
    <i>Single-valued associations</i> are those where there is only one entity at the target end of the relationship. From the employee point of view, whether there is one employee or multiple employees, the target entity (the department) is the sole entity. As such, there are consequently either one-to-one and many-to-one relationships.
</p>

<p>
    The annotations used are @ManyToOne and @OneToOne.
</p>

<pre>
    <code [highlight]="jpaSingleValued" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    To parse this, read the source from the class' point of view. Reading from the Employee literal, of which there are many, is a department, of which there is one. There will be a column in the Employee, known as the <i>foreign key column</i> (in JPA, the "join column", named according to the provider defaults), which references the primary key of the Department table. Thus, the Employee table will store not only the primary keys of its employee entities but also the reference (a foreign key) of the Department entity. The Department table currently does not store references re. the Employees. It does not know anything about Employee entities. As such, the Employee is said to have <b>ownership</b> over the relationship.
</p>

<p>
    By default, the join column name is normally "targetName_id". To customise the name of the join column, annotate the Department field with @JoinColumn(name = "departmentID"), see above.
</p>

<p>
    One-to-one relationships are single-valued and unidirectional. The owner of the relationship is given by the class that references to the other entity.
</p>

<pre>
    <code [highlight]="jpaSingleValued2" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    In the above case, Employee is the owner of the relationship. The @JoinColumn annotation can be applied to the PaySlip reference in the same way. In both one-to-one and many-to-one relationships, one can only traverse from one entity to the other in one direction, that is, from Employee to Department and from Employee to PaySlip. Such relationships are <i>unidirectional</i>.
</p>

<p>
    <i>Bidirectional relationships</i> are those where it is possible to traverse between entities in both directions of the relationship (or continuum). In this case, both entities would need to reference the other entity in their respective Java beans.
</p>

<p>
    To set Office with the ownership via the join column, set as follows. In this case, the Office entity is the owner and the Employee entity is owned.
</p>

<pre>
    <code [highlight]="jpaBidirectional" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<h5>Multivalued associations</h5>

<p>
    When there is more than one target entity, it gives rise to Collection valued relationships. This includes one-to-many and many-to-many relationships.
</p>

<p>
    The one-to-many relationship has been shown previously between employees and the department (above).
</p>

<pre>
    <code [highlight]="oneToMany" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Note that the @OneToMany annotation ensures that one can traverse from Department <i>to</i> Employee and ensure that the relationship is bidirectional. Without the @OneToMany annotation, the relationship would be unidirectional (from Employee to Department).
</p>

<p>
    A single entity on the one-side is unable to store the foreign keys of multiple entities from the many-side (a single cell in a row can only hold one value). To proceed, virtually all one-to-many relationships require a complimentary many-to-one declaration given on the one-side's target. That is, <b>one cannot have a @OneToMany annotation in Department without the @ManyToOne on the Employee side</b>. The converse though is not a requirement, that is, a @ManyToOne annotation in Employee can exist without the @OneToMany in Department. (Each Employee will only need to store one foreign key to one department.) If the @OneToMany annotation is omitted then the JPA provider will build a separate join table (explained shortly) to enable the one-side to store the foreign keys.
</p>

<p>
    The many-to-many relationship is signified by the @ManyToMany annotation. This brings in <i>join tables</i> which are separate tables that are solely purposed to store primary keys of the related entities.
</p>

<pre>
    <code [highlight]="manyToMany" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The owned table (entity) is signified by a field with @ManyToMany(mappedBy = "ownerField") annotation.
</p>

<p>
    With the above relationships, it is necessary to control what other related entities are loaded when a contextual instance is constructed. This is handled with options to the relationship annotations. Note that the provider is not bound to fetch lazily or eagerly, and any fetch annotation is considered a suggestion (consult the provider documentation).
</p>

<h5>Embeddable object persistence</h5>

<p>
    Previously Embeddable objects were given their own allocation in the database when the embedded object was persisted to a database. The above example focused on one entity.
</p>

<p>
    To embed a Collection, annotate the field with @ElementCollection. The HelperClass objects are not JDK entities. Generally all non-JDK entities are flagged with @ElementCollection. This causes the provider to build a secondary table, where one column stores a reference to the Employee table and the remaining columns relate to the fields of the HelperClass.
</p>

<pre>
    <code [highlight]="jpaEmbeddedCollection" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The JPA handles the mapping and build of a separate table. The @CollectionTable overrides the defaults of the secondary table.
</p>

<p>
    Standard JDK entities can be stored along with the owning entity in their own column, as opposed to being stored in a separate table. To handle Collections of standard JDK entities, for example String, use a combination of @ElementCollection and optionally customise the name of the @Column(name = "collectionColumnName") annotations.
</p>

<h5>Sorting Collections</h5>

<p>
    It is recommended to use the Collection interface when defining the variable type of a collection of objects. This is because some providers will use their own more optimised implementation of the collection, rather than the Collections List, ArrayList, Set or Map implementations.
</p>

<p>
    By default, elements in a Java List (indeed any JDK entity) are ordered, ascending, by the primary key. This is symbolised by the optional annotation @OrderBy(). To order by a particular field of the persisted object can be applied with @OrderBy("fieldName asc, secondaryFieldName desc"). Here, the list is sorted by fieldName first, and then by secondaryFieldName. One can add more field names. The token asc and desc represent ascending (default) ordering and descending order, respectively.
</p>

<pre>
    <code [highlight]="jpaSortCollection" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    By default, the ordering of primitive Java types is based on the values. The ordering of non-JDK entities is undefined. Note that the fields of a target non-JDK entity used to sort a collection must be orderable and not another non-JDK entity type.
</p>

<p>
    In cases where there are no orderable fields, an alternative sorting method is signalled by the @OrderColumn annotation. This creates a separate column in the database which mirrors the indices of the Collections List object. As such, the column is zero-based. The name of the column is by default "ClassName_order" and can be overridden with @OrderColumn(name = "indexColumnName") annotation option. The developer then needs to set the index of the List element as desired separately from the JPA provider. The JPA provider will simply order by index.
</p>

<p>
    The persistence of Java Maps (assume that the key and value are JDK entities for now) are handled such that both the key and value are stored in their own columns in a separate table along with a reference to the entity in which they were declared. Use @ElementCollection and a few other annotations.
</p>

<pre>
    <code [highlight]="jpaMapCollection" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    It is possible to use an enumeration as a key to a map. To enforce the provider to use the literals instead of the ordinals of the enumeration, follow the aforementioned persistence mode.
</p>

<pre>
    <code [highlight]="jpaMapEnumKeyCollection" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    One can also use a field of the entity as a key and the entity itself as the value. (For example, a field might be security number of an employee as the key.)
</p>

<pre>
    <code [highlight]="jpaMapFieldKeyCollection" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Note that the key is not stored in a separate table since it already exists, effectively, as a column in the given entity.
</p>

<p>
    One can also use non-JDK entities as keys. For example, the key represents a particular employee in a department and the value (of the map) represents shift allocation (late shift is 0, day shift is 1 etc.). The key column is actually represented by the ID of the employee; the actual non-JDK entity is not stored in the column (cell).
</p>

<pre>
    <code [highlight]="jpaMapEntityKeyCollection" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    One can in theory use Embeddable types as keys, however, their use is not recommended. This is largely because embeddable types do not have their own tables, and are only persisted with the embedded entity. If the embedded entity is not in the database then the embeddable entities are also absent; as a result, the querying of embeddable types is not guaranteed.
</p>

<h5>Enterprise JavaBeans EJBs</h5>

<p>
    Components are self-contained units and can be defined by a class. Java EE gives a component driven APIs, known as EJBs, to help solve business applications. It provides a set of constructs which form an abstract layer and removes (encapsulates) common tasks such as security and scaling amongst others. While historically, EJBs and the JPA were interwoven, now more modern versions of EJB (to date, version 3) are separated but still complimentary to the JPA.
</p>

<p>
    EJBs is largely an annotation driven API. A lot of defaults are set for the developer, and only need to be overridden when needed (in exceptional cases). EJB is aligned with Java EE's CDI and all dependencies are handled automatically by a "EJB container" which specifically manages all forms of EJBs and mirrors much of fuctionality of the CDI. EJB components have automatically managed lifecycles. They are scalable, secure and portable. All transactions are also handled in the background.
</p>

<p>
    The EJB container and the "EJB component model" are the first and second parts of the EJB architecture. The latter is where the developer focuses on. There are different parts of the component model, or different types of EJBs.
</p>

<ul>
    <li>Stateless EJBs</li>
    <li>Stateful EJBs</li>
    <li>Singleton EJBs</li>
</ul>

<p>
    The <i>stateless session bean</i> is an EJB that is designed to complete a given task within the lifetime or cycle of a single method. It is very much like a request-scoped bean. To build a stateless session bean, annotate a POJO with the @Stateless annotation.
</p>

<pre>
    <code [highlight]="simpleEJB" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    All methods defined in an EJB are exclusive. Each method does not assume or know about if other methods in the same EJB were invoked before or after its execution. This is because when the method is invoked, the container will take  one EJB from a predefined pool of EJBs, execute the method and then return the EJB to the pool once the method is finished. If it is invoked again, the container will pass another EJB instance (which may or may not be the same as that passed before) and then return the EJB again on completion. This is an example of a <i>stateless</i> bean. This also means that the methods defined in an EJB are isolated and do not rely on one another.
</p>

<p>
    Stateless EJBs pop in and out of a pool of EJB(s), running the method on a needs basis. This makes stateless EJBs scalable and memory efficient. They do not store the state of the system and are overall expendable units. This also marks the beginning and ending of a transaction (when an EJB is injected and when it is returned).
</p>

<p>
    The complement of a stateless EJB is a <i>stateful</i> EJB. Annotate the POJO with @Stateful. Examples of this include a shopping cart. When methods are invoked, it consults the current state of the system and runs based on its state. The stateful EJB can be placed in passive mode, where it resides in the background without taking up vital resources. It is not committed to a (stateless) pool. The state is unique to a client (no use sharing the same shopping cart).
</p>

<p>
    The third type of EJBs are beans which are instantiated only once, throughout the application lifetime, and are known as <i>Singleton EJBs</i>. They are stateful and are generally used to share information or state across the entire application and furthermore its state is not handled elsewhere. Annotate the bean with @Singleton. To force the bean to run on startup (i.e. eagerly) then use @Startup annotation, otherwise it is instantiated lazily when it is needed (this is the default action).
</p>

<p>
    Stateless and singleton EJBs have two lifecycle stages.
</p>

<ul>
    <li>@PostConstruct - annotates a void method which is invoked after an EJB is "created"</li>
    <li>@PreDestroy - annotates a void method that is invoked before an EJB is destroyed</li>
</ul>

<p>
    Stateful EJBs can apply the @PostConstruct and @PreDestroy annotation but also have:
</p>

<ul>
    <li>@PrePassivate - invokes a void method before the bean is hibernated or put to sleep as it were</li>
    <li>@PostActivate - invokes a void method right after the bean is returned from its passivated state</li>
</ul>

<p>
    Jakarta EE also provides message driven beans. This is covered later.
</p>