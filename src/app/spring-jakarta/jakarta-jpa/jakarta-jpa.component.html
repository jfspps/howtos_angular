<h5>The Java Persistence API (JPA)</h5>

<p>
    The JPA allows Java objects to be mapped to a persistent database. The framework which implements and handles the mapping is referred to as object-relation mapping, or ORM. The ORM handles different database queries, accommodates legacy code and can help perform transactions regardless of where the data is persisted (saved). The default actions can be overridden when required.
</p>

<p>
    The JPA is an interface which is implemented by a number of frameworks or <b>providers</b> or JPA runtime. The default Java EE implementation is <a href="https://www.eclipse.org/eclipselink/" target="_blank">EclipseLink</a> though there are others in use in the enterprise environment including <a href="https://hibernate.org/" target="_blank">Hibernate</a> and <a href="https://spring.io/projects/spring-data-jpa" target="_blank">Spring Data JPA</a>.
</p>

<h5>Setting up the tables and entities</h5>

<p>
    The fundamental (atomic) unit of a JPA component is a POJO, with its class annotated with the @Entity. The @Id annotation is then applied to a field, of type Long, to ensure that each instance is unique with a unique Id.
</p>

<p>
    To this point, the minimum needed to declare a JPA component is done. The name of the table is, without further intervention, the same as the class name. To use a different name, use the @Table(name = "SomeTableName") annotation. So far, the class would look like the following.
</p>

<pre>
    <code [highlight]="jpaTable" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Changing the table name enables POJOs to be stored according to different database requirements. Super classes can form the foundation of JPA entities which have similar fields. This can be implemented by defining an abstract class, itself implementing Serializable.
</p>

<pre>
    <code [highlight]="jpaSuperClass" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The abstract class can then be extended, using the same fields already listed, as follows.
</p>

<pre>
    <code [highlight]="jpaChildClass" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    To override fields in the child class, annotate the child class with @AttributeOverride.
</p>

<pre>
    <code [highlight]="jpaChildClassOverride" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Fields are mapped directly to columns with a column name that is similar to the field name (depends on the JPA implementation), and are by default known as basic fields (types). The optional annotation @Basic of a field, which follows this mapping approach, emphasises this in the code. The actual type stored in the JPA table depends on the implementation. For example, Java Strings are quite often mapped as VARCHAR types.
</p>

<p>
    To customise the JPA column mapping, use the @Column(name = "jpaColumnName") annotation for the desired field. There are other options available, including "length", "nullable" and "unique".
</p>

<p>
    To exclude the mapping of super class or child class field, use the @Transient annotation. In other words, the Java POJO will have a field that is never stored or known when consulting the JPA table. This might be useful if the POJO stores metadata that is not relevant to the database. Otherwise, without the @Transient annotation the field will automatically be mapped as a basic type.
</p>

<h5>Access types</h5>

<p>
    As stated, the JPA implementation is also known as the provider. Access types describe the method which the provider follows to map data to/from the database/Java object. Regarding the Java object, the data can be retrieved or set directly via the fields or though its class' getter and setters.
</p>

<p>
    Take the case when a provider extracts field values from the POJO's fields directly and stores them in the database. This direct mechanism is referred to as "Field Access" and is the default mechanism for all fields of a class, where at least one field not method (normally the @Id annotated field) is given a valid JPA annotation. More fundamentally, the runtime will use 'reflection' to access the field "income" above directly. It will not make use of any getter.
</p>

<p>
    In general, all fields of a class which are then assumed to follow field access are field access types and should be either private or protected. Furthermore, classes which extend said class are also assumed to follow field access. Only the JPA provider will have access to the fields.
</p>

<p>
    "Property Access" is a mechanism where the provider uses getters and setters to access fields' values. The getters and setters must be public. To signal property access of the Id, for example, simply move the @Id annotation from its field to the getter.
</p>

<pre>
    <code [highlight]="jpaPropertyAccess" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Generally, field access tends to be easier to read and is applied more often than property access. It is also possible to follow a "Mixed Access" method which is essentially a mixture of Field and Property access types. This can be achieved by a combination of the @Access and @Transient annotations. This approach is quite rare and not described here.
</p>

<h5>Mapping types and Fetching</h5>

<p>
    Java String types are mapped to the database as VARCHAR (in fact, all mapping types are provider dependent so this discussion attempts to be somewhat generic). Other Java primitive types, wrapper types, enums and Serializable objects can also be mapped to the JPA.
</p>

<p>
    Enum types are normally assigned ordinal values, according to the order they are listed in the class.
</p>

<pre>
    <code [highlight]="jpaEnums" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The ordinals are, by default, stored to the database as integers. This is fine as long as the enumerated list never changes. If however the order changes or an enum is added/removed, then any database stored values will be mis-assigned. To overcome this, the enum can be mapped as a string (a VARCHAR) and use the literal of the enum instead of its ordinal value. In the enum field, use the @Enumerated(EnumType.STRING). Storing as a string tends to be the preferred method.
</p>

<pre>
    <code [highlight]="jpaEnumsFields" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Large entities of variable length (arrays, lists etc.) are represented as CLOBs and BLOBs, that is, character large objects and binary large objects. A primitive array of Java char would be handled by a CLOB whereas a primitive array of Java byte would be handled by a BLOB. The annotation @Lob signals to the JPA provider to handle the Java array or list with large format file routines, optimised for the specific purpose.
</p>

<p>
    When dealing with large files, it is more optimal to retrieve data only when needed, typically through a getter. When an object (a database row) is retrieved from the database, all fields by default (where fields are "eagerly" fetched) are extracted and assigned to the properties of the object. To prevent the JPA provider from retrieving certain fields when a Java object is built with database fields, apply the @Basic(fetch = FetchType.LAZY) annotation to the fields that must be excluded. Only when the object getter (if the field is private) is called does the annotated field get extracted from the database and are said to be "lazily" fetched.
</p>

<p>
    JPA 2.2 introduced support for Java 8's java.time package. The JPA provider will normally use the corresponding Date type in the database. No special annotations are required. Prior version of the JPA required the use of specific annotations to get things going.
</p>

<p>
    Inner classes or classes which are embedded into others (through composition) in Java usually have no purpose other than to serve the Java class they are embedded in. Instances of the outer class typically have fields which are the same type as the inner (embedded) class. To store the inner class, annotate the class to be embedded with @Embeddable and then annotate the field of the class which is embedded with @Embedded. This causes the JPA to save the embedded (inner) class with its own columns, into the 'main class'.
</p>

<pre>
    <code [highlight]="jpaEmbedded" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<h5>Primary keys</h5>

<p>
    Primary keys can take the form of different Java types, not only (wrapped) Long types. Generally, the floating point types like double and Double are not recommended given the representation is not uniformly defined across systems. 
</p>

<p>
    Primary keys generation types vary. The annotation @GeneratedValue(strategy = GenerationType.AUTO) assigns responsibility of primary key generation to the JPA provider and is fine for development. For deployment, this is not recommended since more control is generally expected. The primary key is only set once the transaction (for example, an insertion) has been completed.
</p>

<p>
    The annotation @GeneratedValue(strategy = GenerationType.IDENTITY) directs supporting providers to generate unique primary keys in a primary key column. Not all implementations support a dedicated primary key column.
</p>

<p>
    Some database implementation enable (indeed, expect) custom sequences of integers to be constructed, using the SEQUENCE command. In these cases, the database does not have an automatic schema generator (requires administration). By default, a primary key is constructed as unit integers, that is, the next key is one integer greater than the previous. The SEQUENCE command can be used to define a different sequence. The application of the custom sequence can be directed using the annotations @SequenceGenerator in combination with @GeneratedValue.
</p>

<pre>
    <code [highlight]="jpaCustomSequence" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    A more flexible primary key generator is the Table Generator and tends to be used during deployment. This generates a separate table in the database which specifically acts as a mapper between the Java object and its persistent entity on the database. 
</p>

<pre>
    <code [highlight]="jpaTableGenerator" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Going through each part (above), the name of the table is "pkTable". The primary key column for <i>pkTable</i> is "generatedIDsPKs". The second column in <i>pkTable</i> labelled "latestPK" contains a record of the last primary key that was set. This last column informs the JPA provider what the next key should be, normally one unit integer higher. It examines the value in this column and then proceeds to assign the next entity primary key based on teh value in "latestPK".
</p>

<h5>Relational mapping with JPA</h5>

<p>
    Relationships between two entities can either be unidirectional or bidirectional (explain in more detail shortly). An address related to a employee is normally unidirectional since it makes more sense for the employee to know its address but it does not make sense for an address to know its employee.
</p>

<p>
    The <i>cardinality</i> refers to the number entities at the end of each relationship. From a department's viewpoint, the department will have many employees, and be one-to-many. From the employees viewpoint it would be many-to-one. The cardinality is one for the department and many for the employees, as such.
</p>

<p>
    The <i>ordinality</i> (or "optionality") refers to a boolean which denotes whether or not a entity must be defined when persisting data. Other authors refer to ordinality as the minimum number of entities that must exist in a given relationship. In order for employees to be saved to the database, a department must exist. However, in order for a department to be saved, having employees is not a requirement. From a global viewpoint, the ordinality (in the department-employee relationship) is said to be "0" or false for employee and "1+" or true for the department.
</p>

<h5>Single-valued associations</h5>

<p>
    <i>Single-valued associations</i> are those where there is only one entity at the target end of the relationship. From the employee point of view, whether there is one employee or multiple employees, the target entity (the department) is the sole entity. As such, there are consequently either one-to-one and many-to-one relationships.
</p>

<p>
    The annotations used are @ManyToOne and @OneToOne.
</p>

<pre>
    <code [highlight]="jpaSingleValued" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    To parse this, read the source from the class' point of view. Reading from the Employee literal, of which there are many, is a department, of which there is one. There will be a column in the Employee, known as the <i>foreign key column</i> (in JPA, the "join column", named according to the provider defaults), which references the primary key of the Department table. Thus, the Employee table will store not only the primary keys of its employee entities but also the reference (a foreign key) of the Department entity. The Department table currently does not store references re. the Employees. It does not know anything about Employee entities. As such, the Employee is said to have <b>ownership</b> over the relationship.
</p>

<p>
    By default, the join column name is normally "targetName_id". To customise the name of the join column, annotate the Department field with @JoinColumn(name = "departmentID"), see above.
</p>

<p>
    One-to-one relationships are single-valued and unidirectional. The owner of the relationship is given by the class that references to the other entity.
</p>

<pre>
    <code [highlight]="jpaSingleValued2" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    In the above case, Employee is the owner of the relationship. The @JoinColumn annotation can be applied to the PaySlip reference in the same way. In both one-to-one and many-to-one relationships, one can only traverse from one entity to the other in one direction, that is, from Employee to Department and from Employee to PaySlip. Such relationships are <i>unidirectional</i>.
</p>

<p>
    <i>Bidirectional relationships</i> are those where it is possible to traverse between entities in both directions of the relationship (or continuum). In this case, both entities would need to reference the other entity in their respective Java beans.
</p>

<p>
    To set Office with the ownership via the join column, set as follows. In this case, the Office entity is the owner and the Employee entity is owned.
</p>

<pre>
    <code [highlight]="jpaBidirectional" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<h5>Multivalued associations</h5>

<p>
    When there is more than one target entity, it gives rise to a Collection valued relationships. This includes one-to-many and many-to-many relationships.
</p>

<p>
    The one-to-many relationship has been shown previously between employees and the department (above).
</p>

<pre>
    <code [highlight]="oneToMany" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Note that the @OneToMany annotation ensures that one can traverse from Department <i>to</i> Employee and ensure that the relationship is bidirectional.
</p>

<p>
    The many-to-many relationship is signified by the @ManyToMany annotation. This brings in <i>join tables</i> which are separate tables that are solely purposed to store primary keys of the related entities.
</p>

<pre>
    <code [highlight]="manyToMany" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The owned table (entity) is signified by a field with @ManyToMany(mappedBy = "ownerField") annotation.
</p>

<p>
    With the above relationships, it is necessary to control what other related entities are loaded when a contextual instance is constructed. This is handled with options to the relationship annotations. Note that the provider is not bound to fetch lazily or eagerly, and any fetch annotation is considered a suggestion (consult the provider documentation).
</p>