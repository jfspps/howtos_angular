<h5>The Java Persistence API (JPA)</h5>

<p>
    The JPA allows Java objects to be mapped to a persistent database. The framework which implements and handles the mapping is referred to as object-relation mapping, or ORM. The ORM handles different database queries, accommodates legacy code and can help perform transactions regardless of where the data is persisted (saved). The default actions can be overridden when required.
</p>

<p>
    The JPA is an interface which is implemented by a number of frameworks or <b>providers</b> or JPA runtime. The default Java EE implementation is <a href="https://www.eclipse.org/eclipselink/" target="_blank">EclipseLink</a> though there are others in use in the enterprise environment including <a href="https://hibernate.org/" target="_blank">Hibernate</a> and <a href="https://spring.io/projects/spring-data-jpa" target="_blank">Spring Data JPA</a>.
</p>

<h5>Setting up the tables and entities</h5>

<p>
    The fundamental (atomic) unit of a JPA component is a POJO, with its class annotated with the <span class="annot">@Entity</span>. The <span class="annot">@Id</span> annotation is then applied to a field, of type Long, to ensure that each instance is unique with a unique Id.
</p>

<p>
    To this point, the minimum needed to declare a JPA component is done. The name of the table is, without further intervention, the same as the class name. To use a different name, use the <span class="annot">@Table(name = "SomeTableName")</span> annotation. So far, the class would look like the following.
</p>

<pre>
    <code [highlight]="jpaTable" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Changing the table name enables POJOs to be stored according to different database requirements. Super classes can form the foundation of JPA entities which have similar fields. This can be implemented by defining an abstract class, itself implementing Serializable.
</p>

<pre>
    <code [highlight]="jpaSuperClass" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The abstract class can then be extended, using the same fields already listed, as follows.
</p>

<pre>
    <code [highlight]="jpaChildClass" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    To override fields in the child class, annotate the child class with <span class="annot">@AttributeOverride</span>.
</p>

<pre>
    <code [highlight]="jpaChildClassOverride" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Fields are mapped directly to columns with a column name that is similar to the field name (depends on the JPA implementation), and are by default known as basic fields (types). The optional annotation <span class="annot">@Basic</span> of a field, which follows this mapping approach, emphasises this in the code. The actual type stored in the JPA table depends on the implementation. For example, Java Strings are quite often mapped as VARCHAR types.
</p>

<p>
    To customise the JPA column mapping, use the <span class="annot">@Column(name = "jpaColumnName")</span> annotation for the desired field. There are other options available, including "length", "nullable" and "unique".
</p>

<p>
    To exclude the mapping of super class or child class field, use the <span class="annot">@Transient</span> annotation. In other words, the Java POJO will have a field that is never stored or known when consulting the JPA table. This might be useful if the POJO stores metadata that is not relevant to the database. Otherwise, without the <span class="annot">@Transient</span> annotation the field will automatically be mapped as a basic type.
</p>

<h5>Access types</h5>

<p>
    As stated, the JPA implementation is also known as the provider. Access types describe the method which the provider follows to map data to/from the database/Java object. Regarding the Java object, the data can be retrieved or set directly via the fields or though its class' getter and setters.
</p>

<p>
    Take the case when a provider extracts field values from the POJO's fields directly and stores them in the database. This direct mechanism is referred to as "Field Access" and is the default mechanism for all fields of a class, where at least one field not method (normally the <span class="annot">@Id</span> annotated field) is given a valid JPA annotation. More fundamentally, the runtime will use 'reflection' to access the field "income" above directly. It will not make use of any getter.
</p>

<p>
    In general, all fields of a class which are then assumed to follow field access are field access types and should be either private or protected. Furthermore, classes which extend said class are also assumed to follow field access. Only the JPA provider will have access to the fields.
</p>

<p>
    "Property Access" is a mechanism where the provider uses getters and setters to access fields' values. The getters and setters must be public. To signal property access of the Id, for example, simply move the <span class="annot">@Id</span> annotation from its field to the getter.
</p>

<pre>
    <code [highlight]="jpaPropertyAccess" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Generally, field access tends to be easier to read and is applied more often than property access. It is also possible to follow a "Mixed Access" method which is essentially a mixture of Field and Property access types. This can be achieved by a combination of the <span class="annot">@Access</span> and <span class="annot">@Transient</span> annotations. This approach is quite rare and not described here.
</p>

<h5>Mapping types and Fetching</h5>

<p>
    Java String types are mapped to the database as VARCHAR (in fact, all mapping types are provider dependent so this discussion attempts to be somewhat generic). Other Java primitive types, wrapper types, enums and Serializable objects can also be mapped to the JPA.
</p>

<p>
    Enum types are normally assigned ordinal values, according to the order they are listed in the class.
</p>

<pre>
    <code [highlight]="jpaEnums" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The ordinals are, by default, stored to the database as integers. This is fine as long as the enumerated list never changes. If however the order changes or an enum is added/removed, then any database stored values will be mis-assigned. To overcome this, the enum can be mapped as a string (a VARCHAR) and use the literal of the enum instead of its ordinal value. In the enum field, use the <span class="annot">@Enumerated(EnumType.STRING)</span>. Storing as a string tends to be the preferred method.
</p>

<pre>
    <code [highlight]="jpaEnumsFields" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Large entities of variable length (arrays, lists etc.) are represented as CLOBs and BLOBs, that is, character large objects and binary large objects. A primitive array of Java char would be handled by a CLOB whereas a primitive array of Java byte would be handled by a BLOB. The annotation <span class="annot">@Lob</span> signals to the JPA provider to handle the Java array or list with large format file routines, optimised for the specific purpose.
</p>

<p>
    When dealing with large files, it is more optimal to retrieve data only when needed, typically through a getter. When an object (a database row) is retrieved from the database, all fields by default (where fields are "eagerly" fetched) are extracted and assigned to the properties of the object. To prevent the JPA provider from retrieving certain fields when a Java object is built with database fields, apply the <span class="annot">@Basic(fetch = FetchType.LAZY)</span> annotation to the fields that must be excluded. Only when the object getter (if the field is private) is called does the annotated field get extracted from the database and are said to be "lazily" fetched.
</p>

<p>
    JPA 2.2 introduced support for Java 8's java.time package. The JPA provider will normally use the corresponding Date type in the database. No special annotations are required. Prior version of the JPA required the use of specific annotations to get things going.
</p>

<p>
    Inner classes or classes which are embedded into others (through composition) in Java usually have no purpose other than to serve the Java class they are embedded in. Instances of the outer class typically have fields which are the same type as the inner (embedded) class. To store the inner class, annotate the class to be embedded with <span class="annot">@Embeddable</span> and then annotate the field of the class which is embedded with <span class="annot">@Embedded</span>. This causes the JPA to save the embedded (inner) class with its own columns, into the 'main class'.
</p>

<pre>
    <code [highlight]="jpaEmbedded" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<h5>Primary keys</h5>

<p>
    Primary keys can take the form of different Java types, not only (wrapped) Long types. Generally, the floating point types like double and Double are not recommended given the representation is not uniformly defined across systems. 
</p>

<p>
    Primary keys generation types vary. The annotation <span class="annot">@GeneratedValue(strategy = GenerationType.AUTO)</span> assigns responsibility of primary key generation to the JPA provider and is fine for development. For deployment, this is not recommended since more control is generally expected. The primary key is only set once the transaction (for example, an insertion) has been completed.
</p>

<p>
    The annotation <span class="annot">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> directs supporting providers to generate unique primary keys in a primary key column. Not all implementations support a dedicated primary key column.
</p>

<p>
    Some database implementation enable (indeed, expect) custom sequences of integers to be constructed, using the SEQUENCE command. In these cases, the database does not have an automatic schema generator (requires administration). By default, a primary key is constructed as unit integers, that is, the next key is one integer greater than the previous. The SEQUENCE command can be used to define a different sequence. The application of the custom sequence can be directed using the annotations <span class="annot">@SequenceGenerator</span> in combination with <span class="annot">@GeneratedValue</span>.
</p>

<pre>
    <code [highlight]="jpaCustomSequence" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    A more flexible primary key generator is the Table Generator and tends to be used during deployment. This generates a separate table in the database which specifically acts as a mapper between the Java object and its persistent entity on the database. 
</p>

<pre>
    <code [highlight]="jpaTableGenerator" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Going through each part (above), the name of the table is "pkTable". The primary key column for <i>pkTable</i> is "generatedIDsPKs". The second column in <i>pkTable</i> labelled "latestPK" contains a record of the last primary key that was set. This last column informs the JPA provider what the next key should be, normally one unit integer higher. It examines the value in this column and then proceeds to assign the next entity primary key based on teh value in "latestPK".
</p>

<h5>Relational mapping with JPA</h5>

<p>
    Relationships between two entities can either be unidirectional or bidirectional (explain in more detail shortly). An address related to a employee is normally unidirectional since it makes more sense for the employee to know its address but it does not make sense for an address to know its employee.
</p>

<p>
    The <i>cardinality</i> refers to the number entities at the end of each relationship. From a department's viewpoint, the department will have many employees, and be one-to-many. From the employees viewpoint it would be many-to-one. The cardinality is one for the department and many for the employees, as such.
</p>

<p>
    The <i>ordinality</i> (or "optionality") refers to a boolean which denotes whether or not a entity must be defined when persisting data. Other authors refer to ordinality as the minimum number of entities that must exist in a given relationship. In order for employees to be saved to the database, a department must exist. However, in order for a department to be saved, having employees is not a requirement. From a global viewpoint, the ordinality (in the department-employee relationship) is said to be "0" or false for employee and "1+" or true for the department.
</p>

<h5>Single-valued associations</h5>

<p>
    <i>Single-valued associations</i> are those where there is only one entity at the target end of the relationship. From the employee point of view, whether there is one employee or multiple employees, the target entity (the department) is the sole entity. As such, there are consequently either one-to-one and many-to-one relationships.
</p>

<p>
    The annotations used are <span class="annot">@ManyToOne</span> and <span class="annot">@OneToOne</span>.
</p>

<pre>
    <code [highlight]="jpaSingleValued" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    To parse this, read the source from the class' point of view. Reading from the Employee literal, of which there are many, is a department, of which there is one. There will be a column in the Employee, known as the <i>foreign key column</i> (in JPA, the "join column", named according to the provider defaults), which references the primary key of the Department table. Thus, the Employee table will store not only the primary keys of its employee entities but also the reference (a foreign key) of the Department entity. The Department table currently does not store references re. the Employees. It does not know anything about Employee entities. As such, the Employee is said to have <b>ownership</b> over the relationship.
</p>

<p>
    By default, the join column name is normally "targetName_id". To customise the name of the join column, annotate the Department field with <span class="annot">@JoinColumn(name = "departmentID")</span>, see above.
</p>

<p>
    One-to-one relationships are single-valued and unidirectional. The owner of the relationship is given by the class that references to the other entity.
</p>

<pre>
    <code [highlight]="jpaSingleValued2" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    In the above case, Employee is the owner of the relationship. The <span class="annot">@JoinColumn</span> annotation can be applied to the PaySlip reference in the same way. In both one-to-one and many-to-one relationships, one can only traverse from one entity to the other in one direction, that is, from Employee to Department and from Employee to PaySlip. Such relationships are <i>unidirectional</i>.
</p>

<p>
    <i>Bidirectional relationships</i> are those where it is possible to traverse between entities in both directions of the relationship (or continuum). In this case, both entities would need to reference the other entity in their respective Java beans.
</p>

<p>
    To set Office with the ownership via the join column, set as follows. In this case, the Office entity is the owner and the Employee entity is owned.
</p>

<pre>
    <code [highlight]="jpaBidirectional" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<h5>Multivalued associations</h5>

<p>
    When there is more than one target entity, it gives rise to Collection valued relationships. This includes one-to-many and many-to-many relationships.
</p>

<p>
    The one-to-many relationship has been shown previously between employees and the department (above).
</p>

<pre>
    <code [highlight]="oneToMany" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Note that the <span class="annot">@OneToMany</span> annotation ensures that one can traverse from Department <i>to</i> Employee and ensure that the relationship is bidirectional. Without the <span class="annot">@OneToMany</span> annotation, the relationship would be unidirectional (from Employee to Department).
</p>

<p>
    A single entity on the one-side is unable to store the foreign keys of multiple entities from the many-side (a single cell in a row can only hold one value). To proceed, virtually all one-to-many relationships require a complimentary many-to-one declaration given on the one-side's target. That is, <b>one cannot have a <span class="annot">@OneToMany</span> annotation in Department without the <span class="annot">@ManyToOne</span> on the Employee side</b>. The converse though is not a requirement, that is, a <span class="annot">@ManyToOne</span> annotation in Employee can exist without the <span class="annot">@OneToMany</span> in Department. (Each Employee will only need to store one foreign key to one department.) If the <span class="annot">@OneToMany</span> annotation is omitted then the JPA provider will build a separate join table (explained shortly) to enable the one-side to store the foreign keys.
</p>

<p>
    The many-to-many relationship is signified by the <span class="annot">@ManyToMany</span> annotation. This brings in <i>join tables</i> which are separate tables that are solely purposed to store primary keys of the related entities.
</p>

<pre>
    <code [highlight]="manyToMany" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The owned table (entity) is signified by a field with <span class="annot">@ManyToMany(mappedBy = "ownerField")</span> annotation.
</p>

<p>
    With the above relationships, it is necessary to control what other related entities are loaded when a contextual instance is constructed. This is handled with options to the relationship annotations. Note that the provider is not bound to fetch lazily or eagerly, and any fetch annotation is considered a suggestion (consult the provider documentation).
</p>

<h5>Embeddable object persistence</h5>

<p>
    Previously Embeddable objects were given their own allocation in the database when the embedded object was persisted to a database. The above example focused on one entity.
</p>

<p>
    To embed a Collection, annotate the field with <span class="annot">@ElementCollection</span>. The HelperClass objects are not JDK entities. Generally all non-JDK entities are flagged with <span class="annot">@ElementCollection</span>. This causes the provider to build a secondary table, where one column stores a reference to the Employee table and the remaining columns relate to the fields of the HelperClass.
</p>

<pre>
    <code [highlight]="jpaEmbeddedCollection" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The JPA handles the mapping and build of a separate table. The <span class="annot">@CollectionTable</span> overrides the defaults of the secondary table.
</p>

<p>
    Standard JDK entities can be stored along with the owning entity in their own column, as opposed to being stored in a separate table. To handle Collections of standard JDK entities, for example String, use a combination of <span class="annot">@ElementCollection</span> and optionally customise the name of the <span class="annot">@Column(name = "collectionColumnName")</span> annotations.
</p>

<h5>Sorting Collections</h5>

<p>
    It is recommended to use the Collection interface when defining the variable type of a collection of objects. This is because some providers will use their own more optimised implementation of the collection, rather than the Collections List, ArrayList, Set or Map implementations.
</p>

<p>
    By default, elements in a Java List (indeed any JDK entity) are ordered, ascending, by the primary key. This is symbolised by the optional annotation <span class="annot">@OrderBy()</span>. To order by a particular field of the persisted object can be applied with <span class="annot">@OrderBy("fieldName asc, secondaryFieldName desc")</span>. Here, the list is sorted by fieldName first, and then by secondaryFieldName. One can add more field names. The token asc and desc represent ascending (default) ordering and descending order, respectively.
</p>

<pre>
    <code [highlight]="jpaSortCollection" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    By default, the ordering of primitive Java types is based on the values. The ordering of non-JDK entities is undefined. Note that the fields of a target non-JDK entity used to sort a collection must be orderable and not another non-JDK entity type.
</p>

<p>
    In cases where there are no orderable fields, an alternative sorting method is signalled by the <span class="annot">@OrderColumn</span> annotation. This creates a separate column in the database which mirrors the indices of the Collections List object. As such, the column is zero-based. The name of the column is by default "ClassName_order" and can be overridden with <span class="annot">@OrderColumn(name = "indexColumnName")</span> annotation option. The developer then needs to set the index of the List element as desired separately from the JPA provider. The JPA provider will simply order by index.
</p>

<p>
    The persistence of Java Maps (assume that the key and value are JDK entities for now) are handled such that both the key and value are stored in their own columns in a separate table along with a reference to the entity in which they were declared. Use <span class="annot">@ElementCollection</span> and a few other annotations.
</p>

<pre>
    <code [highlight]="jpaMapCollection" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    It is possible to use an enumeration as a key to a map. To enforce the provider to use the literals instead of the ordinals of the enumeration, follow the aforementioned persistence mode.
</p>

<pre>
    <code [highlight]="jpaMapEnumKeyCollection" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    One can also use a field of the entity as a key and the entity itself as the value. (For example, a field might be security number of an employee as the key.)
</p>

<pre>
    <code [highlight]="jpaMapFieldKeyCollection" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Note that the key is not stored in a separate table since it already exists, effectively, as a column in the given entity.
</p>

<p>
    One can also use non-JDK entities as keys. For example, the key represents a particular employee in a department and the value (of the map) represents shift allocation (late shift is 0, day shift is 1 etc.). The key column is actually represented by the ID of the employee; the actual non-JDK entity is not stored in the column (cell).
</p>

<pre>
    <code [highlight]="jpaMapEntityKeyCollection" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    One can in theory use Embeddable types as keys, however, their use is not recommended. This is largely because embeddable types do not have their own tables, and are only persisted with the embedded entity. If the embedded entity is not in the database then the embeddable entities are also absent; as a result, the querying of embeddable types is not guaranteed.
</p>

<h5>Enterprise JavaBeans EJBs</h5>

<p>
    Components are self-contained units and can be defined by a class. Java EE gives a component driven APIs, known as EJBs, to help solve business applications. It provides a set of constructs which form an abstract layer and removes (encapsulates) common tasks such as security and scaling amongst others. While historically, EJBs and the JPA were interwoven, now more modern versions of EJB (to date, version 3) are separated but still complimentary to the JPA.
</p>

<p>
    EJBs is largely an annotation driven API. A lot of defaults are set for the developer, and only need to be overridden when needed (in exceptional cases). EJB is aligned with Java EE's CDI and all dependencies are handled automatically by a "EJB container" which specifically manages all forms of EJBs and mirrors much of functionality of the CDI. EJB components have automatically managed lifecycles. They are scalable, secure and portable. All transactions are also handled in the background.
</p>

<p>
    The EJB container and the "EJB component model" are the first and second parts of the EJB architecture. The latter is where the developer focuses on. There are different parts of the component model, or different types of EJBs.
</p>

<ul>
    <li>Stateless EJBs</li>
    <li>Stateful EJBs</li>
    <li>Singleton EJBs</li>
</ul>

<p>
    The <i>stateless session bean</i> is an EJB that is designed to complete a given task within the lifetime or cycle of a single method. It is very much like a request-scoped bean. To build a stateless session bean, annotate a POJO with the <span class="annot">@Stateless</span> annotation.
</p>

<pre>
    <code [highlight]="simpleEJB" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    All methods defined in an EJB are exclusive. Each method does not assume or know about if other methods in the same EJB were invoked before or after its execution. This is because when the method is invoked, the container will take  one EJB from a predefined pool of EJBs, execute the method and then return the EJB to the pool once the method is finished. If it is invoked again, the container will pass another EJB instance (which may or may not be the same as that passed before) and then return the EJB again on completion. This is an example of a <i>stateless</i> bean. This also means that the methods defined in an EJB are isolated and do not rely on one another.
</p>

<p>
    Stateless EJBs pop in and out of a pool of EJB(s), running the method on a needs basis. This makes stateless EJBs scalable and memory efficient. They do not store the state of the system and are overall expendable units. This also marks the beginning and ending of a transaction (when an EJB is injected and when it is returned).
</p>

<p>
    The complement of a stateless EJB is a <i>stateful</i> EJB. Annotate the POJO with <span class="annot">@Stateful</span>. Examples of this include a shopping cart. When methods are invoked, it consults the current state of the system and runs based on its state. The stateful EJB can be placed in passive mode, where it resides in the background without taking up vital resources. It is not committed to a (stateless) pool. The state is unique to a client (no use sharing the same shopping cart).
</p>

<p>
    The third type of EJBs are beans which are instantiated only once, throughout the application lifetime, and are known as <i>Singleton EJBs</i>. They are stateful and are generally used to share information or state across the entire application and furthermore its state is not handled elsewhere. Annotate the bean with <span class="annot">@Singleton</span>. To force the bean to run on startup (i.e. eagerly) then use <span class="annot">@Startup</span> annotation, otherwise it is instantiated lazily when it is needed (this is the default action).
</p>

<p>
    Stateless and singleton EJBs have two lifecycle stages.
</p>

<ul>
    <li><span class="annot">@PostConstruct</span> - annotates a void method which is invoked after an EJB is "created"</li>
    <li><span class="annot">@PreDestroy</span> - annotates a void method that is invoked before an EJB is destroyed</li>
</ul>

<p>
    Stateful EJBs can apply the @PostConstruct and @PreDestroy annotation but also have:
</p>

<ul>
    <li><span class="annot">@PrePassivate</span> - invokes a void method before the bean is hibernated or put to sleep as it were</li>
    <li><span class="annot">@PostActivate</span> - invokes a void method right after the bean is returned from its passivated state</li>
</ul>

<p>
    Jakarta EE also provides message driven beans. This is covered later.
</p>

<h5>Transactions with the JPA</h5>

<p>
    Transactions group operations such that the operations only persist data to a database if all operations in the same group succeeded. If one or more operations failed for whatever reason then all operations are nullified or cancelled. The transaction is characterised by four properties (an acronym of ACID):
</p>

<ul>
    <li>Atomicity - the transaction is broken up into its smallest, simplest operations</li>
    <li>Consistency - the outcomes of the transaction following all atomic operations must be consistent with some expectation (requesting cash out of an ATM and then either receiving cash or no cash is consistent; receiving a bowl of fruit is not)</li>
    <li>Isolation - changes within an individual transaction are not globally visible to other transactions in the application until the transaction is successful</li>
    <li>Durability - changes resulting from a transaction endure or persists long after the transaction has completed</li>
</ul>

<p>
    There are two approaches to transaction management: bean management and container management, the latter of which is practised most widely and the default under the Java EE framework. Container management directs the application server to handle the transactions. Bean management requires the developer to manage transactions. 
</p>

<p>
    Since container managed transactions are the default, then all methods are by default transactional. To signal bean management, use the <span class="annot">@TransactionManagement(TransactionManagementType.BEAN)</span> annotation for the given class or bean. This latter approach tends to go against the whole point of EJBs and is not discussed further here. The default would be <span class="annot">@TransactionManagement(TransactionManagementType.CONTAINER)</span>.
</p>

<p>
    One can fine tune container managed transaction operations (by annotating the methods within a container managed transactional bean) with <span class="annot">@TransactionAttribute(TransactionAttributeType.OPTION)</span>, where OPTION = NEVER, OPTION = MANDATORY and OPTION = NOT_SUPPORTED, OPTION = REQUIRED amongst others. "Never" means never run this method as a transaction, "Mandatory" means that the method must be run in a transaction, "Not_supported" means this method does not support being run in a transaction (and an exception is raised if an attempt to do so occurs) and the default "Required" means a method should be invoked in a transaction (if there is no transaction, then one is created in the background). 
</p>

<h5>The persistence context and entity manager</h5>

<p>
    <i>Persistence units</i> are XML file configurations which group persistence entity classes as discrete units. The file "persistence.xml" is stored in /resources/META_INF. Within each persistence unit are settings, for example, data sources and transaction types.
</p>

<pre>
    <code [highlight]="persistenceXML" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    A <i>persistence context</i> is a pool of managed entities (entities managed by the Entity Manager; more shortly). One can think of the persistence context as scratch space or a cache between the model layer and the viewer layer of an MVC framework. All classes that fall under a given persistence unit are managed in their own persistence context by the entity manager. Most of the time, the persistence context is hidden from the application and developer.
</p>

<p>
    The <i>entity manager</i> operates on persistence contexts, of which there can be many. The entity manager itself, like all Java beans, is declared in its own class. If there are more than one persistence units available then it will be necessary to link the entity manager instance with the required persistence unit. If there is only one persistence unit then the CDI will link the entity manager instance automatically. 
</p>

<pre>
    <code [highlight]="entityManagerClass" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The application container handles the lifetime of the entity manager. One then injects the entity manager into a class where the instance is required, without worrying about its lifecycle.
</p>

<p>
    An CRUD-style example of a service example is given below (this example will not compile at present as there are other required annotations missing). The injected QueryService bean is also defined below. 
</p>

<pre>
    <code [highlight]="CRUD_entityManager" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    When a new transaction begins, a persistence context is initialised. Changes to the database entities are not made to the database entries (rows) directly but are instead made to entities pulled (using find()) from the database to the persistence context. Once the transaction is committed, any entities in the persistence context are sent back to the database that have matching IDs, thus saving any changes. The transaction is then no longer in action and the persistence context is flushed.
</p>

<p>
    The key EntityManager methods to note are persist(), find(), detach(), merge() and remove().
</p>

<ul>
    <li>persist() - save the new entity (not already in the persistence context) to a given persistence context (and ultimately the database)</li>
    <li>find() - find the entity on, usually by primary key, from the persistence context or the provider (more below)</li>
    <li>detach() - remove the entity from the persistence context (usually sent to the viewer layer, e.g. JSF); this does not remove the entity from the database</li>
    <li>merge() - the opposite of detach(), placing the object into the persistence context; this is also used to update entities once the transaction is committed</li>
    <li>remove() - remove the entity from the persistence context and database</li>
</ul>

<p>
    Recall that the entity manager operates on the persistence context. A few comments are in order.
</p>

<ul>
    <li>An exception is thrown when persist() is performed on an entity that already exists in the database</li>
    <li>The method find() first queries the persistence context and if the entity cannot be found it then queries the provider's database, and places anything found in to the persistence context</li>
    <li>Detached entities are no longer part of the persistence context. Changes to the detached entity are not automatically applied to the corresponding entity on the database.</li>
    <li>If the entity was found (using find()) on the persistence layer then it automatically becomes detached. Fields of an entity that are set to be loaded lazily can only be retrieved from the database while the entity resides in the persistence context. Hence, lazily loaded fields must be retrieved (if required later) before the entity is detached, either through detach() or find(). Any getter related to a lazily defined field (that has not already been accessed) that is executed on a detached entity will return undefined behaviour. To get around this, first extract the field data before detachment.</li>
</ul>  

<p>
    When the transaction is committed, all entities in the persistence context will be transferred to the database. Subsequent calls to a operation will trigger a new transaction and a new persistence context.
</p>

<pre>
    <code [highlight]="queryServiceClass" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Related entities can be made to persist automatically when the owning entity is persisted. For example, when an employee entity is saved (or furthermore, merged, detached, refreshed or removed), so too would their ParkingSpace entities. This automated form of operations is a referred to as <i>cascading</i>. 
</p>

<pre>
    <code [highlight]="cascadingOps" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    In the above case, whenever an Employee entity is persisted, then its ParkingSpace entity is also persisted.
</p>

<h5>Configuring the persistence unit</h5>

<p>
    The XML to the persistence unit can be configured to runtime properties according to the requirements. Normally there is only one unit in a given XMl configuration (persistence.xml).
</p>

<p>
    The name (in this case, "my-persistence-unit") is the unique identifier of the persistence unit.
</p>

<pre>
    <code [highlight]="persistenceXML" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The transaction type defines the type of transaction used by the entity manager. The JTA is the Java Transactions API and is the default (and most commonly applied). This then directs the container to handle the transactions in the background and is generally recommended overall. (To manually handle transactions, use RESOURCE_LOCAL.)
</p>

<p>
   To set the persistence provider, use the provider tags. Different application servers apply their own default provider and so if the provider tag is absent, then the default set by the application server is assumed. Payara server ships with EclipseLink, for example.
</p>

<pre>
    <code [highlight]="persistenceXMLoptions" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The JTA datasource tag (optional) defines the configuration (usernames, passwords etc.) need to allow the application server to connect to the database. The datasource itself can take the form of an annotation <span class="annot">@DataSourceDefinition()</span> and list the required settings for a class which requires access to the database. The name given in the "jta-data-source" tag references the name attribute of the <span class="annot">@DataSourceDefinition()</span> annotation.
</p>

<pre>
    <code [highlight]="datasourceAnnot" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The datasource can also be set more globally (and arguably more concisely) in the web.xml file (usually located in the same directory as beans.xml: /main/webapp/WEB_INF/).
</p>

<pre>
    <code [highlight]="datasourceXML" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    To define non-JTA datasources, use "non-jta-data-source" tag instead of "jta-data-source". Post Java EE 7, if both JTA and non-JTA tags are omitted from the XML configuration then the application will use an in-memory database.
</p>

<p>
    Classes not marked as JPA classes (i.e. not JPA annotated) are not scanned or included in the given persistence unit if the "exclude-unlisted-classes" tag is set to true. If the tag is set to false, then all classes (regardless if annotated as JPA classes or not) are scanned and included.
</p>

<p>
    Finally, deployment properties are given by the "properties" tag. A commonly set property relates to schema generation (given above) handled by the JPA provider. The other schema generation options are "none" (the default, equivalent to having no "property" tag), "create" and "drop". Scripts can also be managed with the scripts property. A dropped script and a new script (both optional) can be applied.
</p>

<h5>The Java Persistence Query Language JPQL</h5>

<p>
    The JPQL is an API for a Java String based language which resembles much of SQL. JPQL queries on objects/entities in contrast to SQL which queries tables. JPQL can be applied to different SQL vendors and is not typesafe. An alternative to JPQL is the Criteria API, which is typesafe but generally more verbose than JPQL.
</p>

<h5>The mandatory expressions</h5>

<p>
    A <span class="annot">@NamedQuery(name = "someName", query = "JPQL_expression")</span> annotation can be used to define the expression and are compiled with the entity class. They are immutable. The name of the particular query is identified by the name property and query expression is given by the query property. A simple example would be <span class="annot">@NamedQuery(name = "", query = "select d from ClassName d")</span>. The <span class="commands">select</span> and <span class="commands">from</span> keywords are mandatory for all JPQL expressions. The mandatory token "d" is an alias to the ClassName entity, so "select d" (without a WHERE clause) attempts to select and return a list of objects as a whole. All eagerly fetched fields associated with the object will also be retrieved and made available.
</p>

<p>
    JPA 2.2 allows for multiple annotations, as long as the name properties are different. The name property can optionally be substituted with static fields (public static final String fields of the entity class). Legacy code will use <span class="annot">@NamedQueries()</span>.
</p>

<p>
    When data is returned from the database following a JPQL query, the default constructor and annotated fields are used to build the instance. This is why a default, no-arguments constructor is required with all JPA entity classes.
</p>

<p>
    With the query written, the output is passed to the Entity manager. 
</p>

<pre>
    <code [highlight]="jpqlExpression" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    To access a particular field of the entity (of the defined type), use the path expression: <span class="annot">@NamedQuery(name = SomeClass.GET_NAME, query = "select d.className from SomeClass d")</span>. In this case, the return type is String.
</p>

<p>
    To retrieve entities which are not simple Java types (custom Beans) is also performed similarly. The type is effectively cast as appropriate. Furthermore, one could retrieve the field within the entity e.g. <span class="annot">@NamedQuery(name = SomeClass.GET_OBJ_name, query = "select d.customObject.name from SomeClass d")</span>, where customObject is a separate entity that has a relationship with SomeClass entities. The custom class' fields can be lazily loaded.
</p>

<pre>
    <code [highlight]="jpqlExpressionObject" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Note here that the query is made from the point of view of SomeClass, not CustomObject. It is also possible to extract multiple fields from a custom entity by separating the reqeusted fields with commas. For example, <span class="annot">@NamedQuery(name = SomeClass.GET_OBJ_name, query = "select d.customObject.name, d.customObject.date from SomeClass d")</span>. The return type in this case is <span class="commands">Collection&lt;Object[]&gt;</span>, where each field (of the same type) is stored in its own Collection element. The entity manager call would be:
</p>

<pre>
    <code [highlight]="jpqlCollection" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    An alternative to combined path expressions are constructor expressions. This is implemented first by preparing for a new POJO which contains the fields that are needed. View it as a data-transfer object, DTO. The return type is then the POJO with <span class="annot">@NamedQuery(name = "DTO", query = "select new packagePath.POJO(d.field1, d.field2, d.field3) from ClassName d")</span> declared in the original (non-DTO) class. 
</p>

<pre>
    <code [highlight]="dtoOnstructorExpression" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    In this case, the all-args constructor of POJO is used as the return to the query.
</p>

<pre>
    <code [highlight]="jpqlCollection2" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    More on the <span class="commands">from EntityClass alias</span> clause. The EntityClass, as shown, must be a JPA entity. The alias must be unique across the given expression. To extract from an entity referenced in the queried class (a collection) through a join expression use the following. 
</p>

<pre>
    <code [highlight]="joinFrom" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Optionally, one can prefix the collection alias with the "distinct" keyword to, like SQL, retrieve unique records.
</p>

<p>
    Querying Java Maps. By default, queries compare the value of the map, not the key (demonstrated above). 
</p>

<p>
    When an entity has been detached from the persistence context (when sent to the viewer layer for example) any lazily loaded fields not already loaded are inaccessible. The normal workaround is to set the field as eagerly loaded or to use the JPQL "fetch join" expression. The latter can be applied even when the entity is in a detached state. Note that this feature only relates to JPQL "join fetch" expression and not other routine Java getters. The field remains lazily loaded. This is demonstrated next.
</p>

<pre>
    <code [highlight]="joinFetch" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>