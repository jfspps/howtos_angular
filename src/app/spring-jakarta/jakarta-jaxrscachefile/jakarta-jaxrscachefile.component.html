<h5>Caching</h5>

<p>
    Data usually has to pass between the client and server via a number of entities (Content Delivery Networks CDNs, proxies (intermediary servers), etc.) and each point can cache data. The process is quite involved.
</p>

<p>
    If the client is required to cache data then it would need to know if what it currently holds is still valid or up to date. The client would have to receive notice from the web service.
</p>

<p>
    The example below shows how an HTTP header "entity tag" (or ETag) is initialised and used to inform the client about the current state (version) of cached data.
</p>

<pre>
    <code [highlight]="caching" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<h5>Content negotiation</h5>

<p>
    Since some clients and web services support differently formatted payloads (plain text, XML, JSON etc.) a hierarchy of the formats available is normally provided so that if one entity cannot consume or produce a given format then it will defer to the next available format. The other entity will then attempt to satisfy the format. In this context, the client and server are said to negotiate regarding the content exchanged and is the basis of "content negotiation". The goal is to enable a web service to provide data to clients with differing requirements.
</p>

<p>
    There are various ways of setting the precedence of the content type, some are based on the given order of a list of formats and others are based on a "q" value (q = 0 having lowest precedence and q = 1 having the highest precedence). Further details are not discussed here.
</p>

<p>
    The choices available are stored in the HTTP "Accept" request header and so with JAX-RS, the header of the request is queried by the web service when responding. In the example below, the web service offers two options: JSON and XML.
</p>

<pre>
    <code [highlight]="contentNegotiation" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Note that option 1 is more hard-coded and limits the client to XML or JSON. Option 2 is usually more flexible and may expose more media types that are not previously known to the developer. 
</p>

<h5>Uploading files to the server</h5>

<p>
    File uploading is outlined with an example below.
</p>

<pre>
    <code [highlight]="fileUpload" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<h5>Downloading files from the server</h5>

<p>
    File downloading is outlined below. The <span class="annot">@Produces()</span> annotation is swapped for the <span class="annot">@Consumes()</span> annotation.
</p>

<pre>
    <code [highlight]="fileDownload" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Depending on how the request for a download was made, the body of the response will contain the byte-array format of the image. For a web browser, this will normally trigger a download dialogue box.
</p>