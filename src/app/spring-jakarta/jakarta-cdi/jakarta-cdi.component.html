<h5>Context Dependency Injection CDI</h5>

<p>
    <b>Inversion of control (IOC)</b> is a paradigm which enables individual components of a program to be loosely
    coupled with one another. It makes large scale programs to be extended more easily and tested more independently.
    The primary responsibility of instantiating and supplying (injecting) objects is not handled by the method executed.
    IOC is implemented by <b>dependency injection (DI)</b>, in which the container manages the instantiating of classes
    (beans) and injects them into a method.
</p>

<p>
    Some of the main features of CDI 2.0 (an API that implements DI) are:
</p>

<ul>
    <li>Typesafe dependency: the dependencies are typesafe; the compilation or runtime execution of the context is
        halted if the wrong type is passed to a method</li>
    <li>Lifecycle contexts: the context (where beans are instantiated) and objects (contextual instances) have a
        lifecycle and are automatically managed in the background by the container</li>
    <li>Interceptors: these can perform tasks before, during and after a method is executed (typical example includes
        the logging of metadata for a specific method)</li>
    <li>Events: these are responses to particular events executed by the user or program, and can be asynchronous</li>
    <li>Service Provider Interface: these are extensions available to the CDI</li>
</ul>

<h5>Bean discovery mode</h5>

<p>
    <b>Bean discovery</b> is handled by the <i>beans.xml</i> configuration. By default, the <i>bean-discovery-mode</i> is
    set to "annotated" and directs only annotated classes (beans) to be managed by the CDI runtime. The other discovery
    mode is "all" and directs all beans to to be managed by the CDI runtime. Generally, most projects use the "all"
    mode.
</p>

<p>
    Assuming the program runs, then the object will not be null and can be accessed by its reference from anywhere in the application.
</p>

<h5>CDI container, beans and contextual instances</h5>

<p>
    The CDI container can be viewed as factory where beans (classes which will be instantiated in preparation for DI) are managed and looks out for adherence to the API standards. Failure to do so prevents the program from running.
</p>

<p>
    The context is a part of the container where beans are instantiated. Contexts build objects, known as contextual instances and there can be more than one context present in the container. Dependencies can be injected through class fields, via a constructor or directly into methods. To do so, set the field/constructor/method with the @Inject annotation.
</p>

<h5>Lifecycle callbacks</h5>

<p>
    The <span class="annot">@PostConstruct</span> and <span class="annot">@PreDestroy</span> are applied to methods which will be executed, respectively, once the contextual instance is built and before it is destroyed. The access modifiers private, package-private (i.e. nothing declared), protected (visible to parent and child classes only) and public can be applied.
</p>

<h5>Managed beans and bean types</h5>

<p>
    Managed beans are simply beans managed by the CDI runtime. Beans which appear to be of the same type: they implement the same interface (and all parent interfaces before it), for example. The correct dependency is injected via a mechanism known as <b>CDI qualifiers</b>.
</p>

<p>
    If one has an interface which can be implemented differently, such as:
</p>

<pre>
    <code [highlight]="commonInterface" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>One can direct the CDI container to instantiate a specific bean that implements CommonInterface. First define said bean:</p>

<pre>
    <code [highlight]="qualifyBean" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Then set a custom annotation CDI qualifier:
</p>

<pre>
    <code [highlight]="cdiQualifiers" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The <span class="annot">@Retention</span> annotation is explained later. A separate custom interface annotation (CustomBean) is required for each different implementation of CommonInterface.** Inject a specific implementation of CommonInterface:
</p>

<pre>
    <code [highlight]="injectHere" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Note that the above CustomBean refers to one specific type of bean. **A more concise way of declaring a CDI qualifier involves enumerations (it is possible to use other types, though enums are generally safer). That is, only one CustomBean interface needs to be defined.
</p>

<pre>
    <code [highlight]="cdiQualifierEnum" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The important part is pairing SomeClass with CustomBeanManager's value. This is done by setting the specific class with the given value. Note that the <span class="annot">@annotationsPackagePath.CustomBean</span> is no longer needed.
</p>

<pre>
    <code [highlight]="qualifyBeanEnum" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Then use the SomeClass (TYPE2) implementation with the following.
</p>

<pre>
    <code [highlight]="injectHereEnum" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<h5>CDI scopes and contexts</h5>

<p>
    The context is the environment within the container where contextual instances are created and reside. There can be more than one context in the given container. The container is responsible for the lifecycle of all contexts. When a bean is instantiated in a particular context, the bean is said to be in scope of the given context and is bound to that context. Scopes are definitions that associate a managed bean with a context. That is, it defines which context is responsible for the lifecycle of the bean.
</p>

<p>
    Any bean that is not assigned a scope is by default assigned the DependentScope (optionally, the bean can be annotated with <span class="annot">@Dependent</span> to signify this). The DependentScope is a class which defines the scope of a bean that is not a dependency of any particular context when instantiated. When it is injected into, say, Bean2, which is assigned a scope (so other than DependentScope) then the injected bean will inherit whatever scope Bean2 is assigned. This is why it is called DependentScope because the injected bean's scope depends on what other bean it is injected into.
</p>

<p>
    All CDI beans are <i>lazily</i> created: they are only instantiated when needed. There are other scopes:
</p>

<ul>
    <li>Request scoped (annotate bean with <span class="annot">@RequestScoped</span>): a context which creates and destroys beans based on HTTP requests</li>
    <li>Session scoped (annotate bean with <span class="annot">@SessionScoped</span>): a context based on client-server sessions (conversations as such), beans are created on session startup and destroyed when a session is closed. Session contextual instances tend to run over long periods and consequently bound contextual instances can persist in memory for the same duration. To optimise memory use on the server, contextual instances are set into service when needed but then <i>passivated</i> by the container (placed into hibernation) until they are needed again.</li>
    <li>Application scoped (annotate bean with <span class="annot">@ApplicationScoped</span>): lifecycle of the bean parallels the lifetime of the application. Consequently, only one contextual instance of the given type can exist and as such application scoped instances follow a Singleton pattern.</li>
    <li>Conversation scoped (annotate with <span class="annot">@ConversationScoped</span>): related to JSF API and can partly be viewed as Models in Spring. They have a lifetime shorter than the session and traverse along HTTP requests.</li>
</ul>

<h5>CDI Producers</h5>

<p>
    Producers are non-void methods (annotated with <span class="annot">@Produces</span>) that convert Java classes, not normally managed or owned, into CDI managed beans. The method must return an object. The method parameters are optional but must be injectable. All are handled by the container.
</p>

<p>
    The return object is not normally handled by the CDI container e.g. an instance of Logger. 
</p>

<pre>
    <code [highlight]="producerMethod" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Any class which attempts to inject a Logger instance automatically triggers the execution of produceLogger() and returns the Logger instance as a contextual instance.
</p>

<pre>
    <code [highlight]="injectLogger" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The Producer converts Logger into a bean, scoped as the DependentScope, and in many ways can be viewed as implementations of Factory design patterns. The above injection in particular is scoped according to the calling class.
</p>

<p>
    Any object from the Java library can be returned and managed as a bean e.g. a Collections API List of Strings, for example.
</p>

<pre>
    <code [highlight]="producerMethodList" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Classes can also be injected directly as managed beans using fields. This works if the non-bean does not require further inquiry (e.g. EntityManager).
</p>

<pre>
    <code [highlight]="producerMethodListField" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Related to the above discussion about CDI qualifiers, the producers (methods or fields) can be qualified to eliminate ambiguity. Consequently, an injection of CommonInterface will invoke the above Producer method.
</p>

<pre>
    <code [highlight]="producerMethodListQualifier" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Methods or events can be executed to the contextual instance, produced from the Produces annotation, before the instance is destroyed. This can be achieved by using the <span class="annot">@Disposes</span> annotation.
</p>

<pre>
    <code [highlight]="producerMethodListFieldDisposes" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<h5>CDI Interceptors</h5>

<p>
    Interceptors intercept method calls and execute other functions (auditing, security etc.) before the method is executed. Interceptors can also help decide if the method call goes ahead.
</p>

<p>
    Interceptors are implemented by declaring the method that is intercepted and the interceptor code (the binding code)that is executed. Typically, a custom annotation is defined, giving the target type i.e. does the interceptor intercept a method or class. If a class is the target then all methods of the class are intercepted. The approach is similar to Aspect Orientated Programming paradigms.
</p>

<pre>
    <code [highlight]="interceptor" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The interceptor binding code is demonstrated next. This could run, for example, security related functions. The InvocationContext interface is used to pass info related to calling method and its class so decisions about what to do now next can be carried out.
</p>

<pre>
    <code [highlight]="interceptorBinding" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<h5>CDI events</h5>

<p>
    Disparate classes can be linked, such that one observes the events (occurrences) of another. The observer class (an event observer) is not dependency. One can trigger the observer class (the event is fired by the observed class) to run its own code. The observed class passes data (a payload) to the observer class and the observer class processes the payload. Since CDI 2.0, the observer class can run asynchronously to the observed class.
</p>

<p>
    Less abstractly, a user can book tickets online and the data can be managed by a dependency. The dependency can then fire an event (e.g. ticketsBooked) and send data re. the booking to another observer class. The ticket booking dependency continues on with whatever it was assigned to do and the event observer takes the payload and can process it independently of the booking dependency. Another example are mouse clicks. An application processes the action of a mouse click, usually through the OS, while the class fires an event, onClick, which the application then responds to and performs some directed action.
</p>

<p>
    The Event interface allows the application to fire events. The Event interface (as an injected instance) receives the payload. The payload is defined by its own POJO.
</p>

<pre>
    <code [highlight]="payLoad" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    One then injects an instance of the Event interface, usually at the controller level.
</p>

<pre>
    <code [highlight]="injectEvent" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The observer class is then defined and lists the methods that are executed when it receives a payload. Note how specific events can be fired. Each method that can be invoked are more generally referred to as "observers".
</p>

<pre>
    <code [highlight]="observerClass" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    The custom annotation <span class="annot">@SpecificEvent</span> is given below.
</p>

<pre>
    <code [highlight]="specificEventAnnotation" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    If there are multiple observers (methods) then the CDI will execute all in a random order. A specific order can be established by passing the <span class="annot">@Priority(100)</span> annotation. Passing lower integers into the <span class="annot">@Priority()</span> annotation causes the CDI to place more priority to the annotated observer.
</p>

<pre>
    <code [highlight]="eventObserverPriority" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>