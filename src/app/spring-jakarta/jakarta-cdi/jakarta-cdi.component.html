<h5>Context Dependency Injection CDI</h5>

<p>
    <b>Inversion of control (IOC)</b> is a paradigm which enables individual components of a program to be loosely
    coupled with one another. It makes large scale programs to be extended more easily and tested more independently.
    The primary responsibility of instantiating and supplying (injecting) objects is not handled by the method executed.
    IOC is implemented by <b>dependency injection (DI)</b>, in which the container manages the instantiating of classes
    (beans) and injects them into a method.
</p>

<p>
    Some of the main features of CDI 2.0 are:
</p>

<ul>
    <li>Typesafe dependency: the dependencies are typesafe; the compilation or runtime execution of the context is
        halted if the wrong type is passed to a method</li>
    <li>Lifecycle contexts: the context (where beans are instantiated) and objects (contextual instances) have a
        lifecycle and are automatically managed in the background</li>
    <li>Interceptors: these can perform tasks before, during and after a method is executed (typical example includes
        the logging of metadata for a specific method)</li>
    <li>Events: these are responses to particular events executed by the user or program, and are asynchronous</li>
    <li>Service Provider Interface: these are extensions available to the CDI</li>
</ul>

<h5>Bean discovery mode</h5>

<p>
    <b>Bean discovery</b> is handled by the <i>beans.xml</i> configuration. By default, the <i>bean-discovery-mode</i> is
    set to "annotated" and directs only annotated classes (beans) to be managed by the CDI runtime. The other discovery
    mode is "all" and directs all beans to to be managed by the CDI runtime. Generally, most projects use the "all"
    mode.
</p>

<p>
    Assuming the program runs, then the object will not be null and can be accessed by its reference from anywhere in the application.
</p>

<h5>CDI container, beans and contextual instances</h5>

<p>
    The CDI container can be viewed as factory where beans (classes which will be instantiated in preparation for DI) are managed and looks out for adherence to the API standards. Failure to do so prevents the program from running.
</p>

<p>
    The context is a part of the container where beans are instantiated. Contexts build objects, known as contextual instances. Dependencies can be injected through class fields, via a constructor or directly into methods. To do so, set the field/constructor/method with the @Inject annotation.
</p>

<h5>Lifecycle callbacks</h5>

<p>
    The @PostConstruct and @PreDestroy are applied to methods which will be executed, respectively, once the contextual instance is built and before it is destroyed. The access modifiers private, package-private (i.e. nothing declared), protected (visible to parent and child classes only) and public can be applied.
</p>

<h5>Managed beans and bean types</h5>

<p>
    Managed beans are simply beans managed by the CDI runtime. Beans which appear to be of the same type: they implement the same interface (and all parent interfaces before it), for example. The correct dependency is injected via a mechanism known as <b>CDI qualifiers</b>.
</p>

<p>
    If one has an interface which can be implemented differently, such as:
</p>

<pre>
    <code [highlight]="commonInterface" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>One can direct the CDI container to instantiate a specific bean that implements CommonInterface. First define said bean:</p>

<pre>
    <code [highlight]="qualifyBean" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Then set a custom annotation CDI qualifier:
</p>

<pre>
    <code [highlight]="cdiQualifiers" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>

<p>
    Then inject a specific implementation of CommonInterface:
</p>

<pre>
    <code [highlight]="injectHere" (highlighted)="onHighlight($event)" [languages]="lang"></code>
</pre>